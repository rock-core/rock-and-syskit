<!DOCTYPE html>
<html lang="en">
    <head>
        <meta content="IE=edge" http-equiv="X-UA-Compatible">
        <meta charset="utf-8">
        <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Building Robots with Rock and Syskit</title>

        <link href="../images/favicon.ico" rel="icon" type="image/ico" relative="true" />
        <link href="../stylesheets/site.css" rel="stylesheet" />
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    </head>

    <body class="libraries libraries_cpp_libraries">
            <!-- top navbar -->
    <nav class="navbar navbar-inverse">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">
                    <li><a href="../">Home</a></li>
                    <li><a href="../about.html">About</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3" role="complementary">
                <nav class="docs-sidebar" data-spy="affix">
                    <ul class="nav"><li class='child'><a href="../">Building robots with Rock and Syskit</a></li><li class='parent'><span class='parent-label'><a href="../basics/">Basics</a></span><ul><li class='child'><a href="../basics/">Introduction</a></li><li class='child'><a href="../basics/installation.html">Installation</a></li><li class='child'><a href="../basics/day_to_day.html">Day-to-day Workspace Commands</a></li><li class='child'><a href="../basics/getting_started.html">Getting Started</a></li><li class='child'><a href="../basics/composition.html">Compositions</a></li><li class='child'><a href="../basics/constant_generator.html">Constant Generator</a></li><li class='child'><a href="../basics/devices.html">Profiles and Devices</a></li><li class='child'><a href="../basics/deployment.html">Deployment</a></li><li class='child'><a href="../basics/publishing.html">Publishing</a></li><li class='child'><a href="../basics/validation.html">Configuration Consistency</a></li><li class='child'><a href="../basics/recap.html">Recap</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../runtime_overview/">Runtime Overview</a></span><ul><li class='child'><a href="../runtime_overview/">Introduction</a></li><li class='child'><a href="../runtime_overview/task_structure.html">Task Structures</a></li><li class='child'><a href="../runtime_overview/event_loop.html">Event Loop</a></li><li class='child'><a href="../runtime_overview/exceptions.html">Errors</a></li><li class='child'><a href="../runtime_overview/live_data.html">Live Data Visualization</a></li><li class='child'><a href="../runtime_overview/recap.html">Recap</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../workspace/">Workspace and Packages</a></span><ul><li class='child'><a href="../workspace/">Introduction</a></li><li class='child'><a href="../workspace/conventions.html">Conventions</a></li><li class='child'><a href="../workspace/setup.html">Starting a New Project</a></li><li class='child'><a href="../workspace/add_packages.html">Adding new packages</a></li><li class='child'><a href="../workspace/os_dependencies.html">OS Dependencies</a></li><li class='child'><a href="../workspace/global_configuration.html">Global Configuration</a></li><li class='child'><a href="../workspace/testing.html">Test Integration</a></li><li class='child'><a href="../workspace/managing.html">Build configuration design</a></li><li class='child'><a href="../workspace/troubleshooting.html">Troubleshooting</a></li></ul></li><li class='parent active'><span class='parent-label'><a href="./">Libraries</a></span><ul><li class='child'><a href="./">Introduction</a></li><li class='child'><a href="add_packages.html">Add packages</a></li><li class='child active'><a href="cpp_libraries.html">C++ Library Packages</a></li><li class='child'><a href="geometric_transformations.html">Geometric Transformations in C++ Libraries</a></li><li class='child'><a href="ruby_libraries.html">Ruby Library Packages</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../components/">Components</a></span><ul><li class='child'><a href="../components/">Writing Components</a></li><li class='child'><a href="../components/orogen_packages.html">oroGen Packages</a></li><li class='child'><a href="../components/defining_types.html">Defining Types</a></li><li class='child'><a href="../components/importing_types.html">Importing Types</a></li><li class='child'><a href="../components/interface.html">Interface</a></li><li class='child'><a href="../components/state_machine.html">State Machine</a></li><li class='child'><a href="../components/writing_the_hooks.html">Writing the Hooks</a></li><li class='child'><a href="../components/timestamping.html">Timestamping</a></li><li class='child'><a href="../components/stream_aligner.html">Stream Aligner</a></li><li class='child'><a href="../components/geometric_transformations.html">Geometric Transformations</a></li><li class='child'><a href="../components/deployment.html">Deployments</a></li><li class='child'><a href="../components/runtime.html">Runtime</a></li><li class='child'><a href="../components/testing.html">Testing</a></li><li class='child'><a href="../components/types_in_ruby.html">Types in Ruby</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../component_networks/">Designing Component Networks</a></span><ul><li class='child'><a href="../component_networks/">Introduction</a></li><li class='child'><a href="../component_networks/composition.html">Compositions</a></li><li class='child'><a href="../component_networks/profiles.html">Profiles</a></li><li class='child'><a href="../component_networks/reusable_networks.html">Reusable Networks</a></li><li class='child'><a href="../component_networks/devices_and_busses.html">Robot definition&colon; Devices and Busses</a></li><li class='child'><a href="../component_networks/dynamic_services.html">Dynamic Services</a></li><li class='child'><a href="../component_networks/geometric_transformations.html">Geometric Transformations</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../coordination/">Coordination</a></span><ul><li class='child'><a href="../coordination/">Introduction</a></li><li class='child'><a href="../coordination/generalities.html">Generalities</a></li><li class='child'><a href="../coordination/tasks_and_events.html">Tasks and Events</a></li><li class='child'><a href="../coordination/action_methods.html">Action Methods</a></li><li class='child'><a href="../coordination/action_state_machines.html">Action State Machines</a></li><li class='child'><a href="../coordination/component_networks.html">Component Networks</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../simulation/">Simulation with Gazebo</a></span><ul><li class='child'><a href="../simulation/">Introduction</a></li><li class='child'><a href="../simulation/models_links_and_joints.html">Models, Links, Joints and Sensors</a></li><li class='child'><a href="../simulation/plugins.html">Plugins</a></li><li class='child'><a href="../simulation/transformer.html">Transformer</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../syskit_error_handling/">Error Handling</a></span><ul><li class='child'><a href="../syskit_error_handling/">Introduction</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../log_management/">Log Management</a></span><ul><li class='child'><a href="../log_management/">Introduction</a></li><li class='child'><a href="../log_management/runtime.html">Log Generation at Runtime</a></li><li class='child'><a href="../log_management/datastore.html">Storing Logs</a></li><li class='child'><a href="../log_management/jupyter.html">Log Analysis with Jupyter</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../testing/">Testing and Debugging</a></span><ul><li class='child'><a href="../testing/">Introduction</a></li><li class='child'><a href="../testing/component.html">Component Tests</a></li><li class='child'><a href="../testing/integration.html">Integration Tests</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../cookbook/">Cookbook</a></span><ul><li class='child'><a href="../cookbook/">Introduction</a></li><li class='child'><a href="../cookbook/device_drivers.html">Device Drivers with iodrivers_base</a></li><li class='child'><a href="../cookbook/http_api.html">Control and Monitoring through a HTTP API</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../deprecations/">Deprecated Behaviors</a></span><ul><li class='child'><a href="../deprecations/">Introduction</a></li><li class='child'><a href="../deprecations/backward_compatible_naming.html">Backward compatible naming</a></li><li class='child'><a href="../deprecations/update_properties.html">Introduction of the `update_properties` method</a></li></ul></li></ul>
                </nav>
            </div>
            <div class="col-md-9" role="main">
                <h1 class="no_toc" id="c-library-packages">C++ Library Packages</h1>

<ul id="markdown-toc">
  <li><a href="#creating-and-adding-packages-to-the-workspace" id="markdown-toc-creating-and-adding-packages-to-the-workspace">Creating and Adding Packages to the Workspace</a></li>
  <li><a href="#integrating-3rd-party-library" id="markdown-toc-integrating-3rd-party-library">Integrating 3rd-party library</a></li>
  <li><a href="#cxx_standard" id="markdown-toc-cxx_standard">Picking the C++ Standard</a></li>
  <li><a href="#package-dependencies" id="markdown-toc-package-dependencies">Package Dependencies</a></li>
  <li><a href="#unconventional_dependencies" id="markdown-toc-unconventional_dependencies">Working around Unconventional 3rd Party Packages</a></li>
  <li><a href="#conventions-for-library-design" id="markdown-toc-conventions-for-library-design">Conventions for library design</a></li>
  <li><a href="#optional-features" id="markdown-toc-optional-features">Optional Features</a></li>
  <li><a href="#tests" id="markdown-toc-tests">Tests</a></li>
  <li><a href="#debugging-in-vscode" id="markdown-toc-debugging-in-vscode">Debugging in VSCode</a></li>
  <li><a href="#rock-cmake-macros" id="markdown-toc-rock-cmake-macros">The Rock CMake macros</a></li>
  <li><a href="#using-rocks-text-logger" id="markdown-toc-using-rocks-text-logger">Using Rock's text logger</a></li>
  <li><a href="#rockcmake-reference-documentation" id="markdown-toc-rockcmake-reference-documentation">Rock.cmake Reference Documentation</a>    <ul>
      <li><a href="#executable-targets-rockexecutable" id="markdown-toc-executable-targets-rockexecutable">Executable Targets (<code>rock_executable</code>)</a></li>
      <li><a href="#library-targets-rocklibrary" id="markdown-toc-library-targets-rocklibrary">Library Targets (<code>rock_library</code>)</a></li>
      <li><a href="#rock_testsuite" id="markdown-toc-rock_testsuite">Boost Test Suite Targets (<code>rock_testsuite</code>)</a></li>
      <li><a href="#rock_gtest" id="markdown-toc-rock_gtest">GTest Test Suite Targets (<code>rock_gtest</code>)</a></li>
    </ul>
  </li>
</ul>

<p>While Rock is designed to allow you for the separation between functionality
and framework, if you feel so inclined, Rock provides a C++ library template.
This template solves some of the common problems with setting up a C++ library
(build system, …) and obviously integrate as-is with the rest of a Rock
system.</p>

<p><strong>However</strong> there is nothing that forces you to use the Rock library template.
Autoproj generically integrates with autotools and cmake packages. One can also
set up a custom package for more exotic systems (such as some old packages that
use "plain make")</p>

<p>The only constraint when the aim is to create a library that will be integrated
in a Rock component is to provide a pkg-config file for it. This is how orogen
resolves its dependencies.</p>

<h2 id="creating-and-adding-packages-to-the-workspace">Creating and Adding Packages to the Workspace</h2>

<p>This is covered in details in the <a href="../workspace/add_packages.html">Workspace and Packages section</a></p>

<p><strong>Executive Summary</strong>: You need to first pick a category and a name <a href="../workspace/conventions.html">the workspace
conventions</a> for information about how to name
your library package.</p>

<p>Rock then provides a library template. One can create a new library with</p>

<div class="highlight"><pre class="highlight plaintext"><code>rock-create-lib library_dir
</code></pre></div>
<p>e.g.</p>

<div class="highlight"><pre class="highlight plaintext"><code>cd drivers
rock-create-lib imu_advanced_navigation_anpp
</code></pre></div>
<p>This library creates a dummy class and a dummy executable that uses this class.
It is great at providing you with the example CMake code for both library and
tests.</p>

<p>When using VSCode, the package will not be picked up by the <a href="https://marketplace.visualstudio.com/items?itemName=rock-robotics.rock"><code>vscode-rock</code>
extension</a>
until it is part of the main manifest.
Adding the package path to the layout section of <code>autoproj/manifest</code> is
enough at this stage. You will however have to <a href="../workspace/add_packages.html">define the
package</a> in the autobuild and <code>source.yml</code>
files before you push the updated manifest to your team members. For instance,
when creating <code>drivers/imu-myahrs</code> one would do</p>

<div class="highlight"><pre class="highlight plaintext"><code>rock-create-lib drivers/imu-myahrs
</code></pre></div>
<p>and then add</p>

<div class="highlight"><pre class="highlight yaml"><code><span class="na">layout</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">...</span>
  <span class="pi">-</span> <span class="s">drivers/imu-myahrs</span>
</code></pre></div>
<h2 id="integrating-3rd-party-library">Integrating 3rd-party library</h2>

<p>Rock packages - even those using the Rock CMake macros - are <strong>not</strong> dependent
on autoproj. Autoproj is an external helper tool, but in no way does it interact
with the package's build process. It is therefore perfectly feasible to build and
use 3rd party libraries in a Rock system.</p>

<p>When doing so, try to follow these guidelines:</p>

<ul>
  <li>do not change the package unless strictly necessary. The one exception for
which there is currently no good solution is to provide a pkg-config file for
orogen integration. If that is needed, you will probably want to integrate
this change <a href="../workspace/add_packages.html#patch">as a patch</a> into your build
configuration. Also, try to get this patch in the package's mainline, it will
make things easier down the line.</li>
  <li>provide <a href="../workspace/add_packages.html#manifest_xml">a package manifest</a> in the
package set.</li>
</ul>

<h2 id="cxx_standard">Picking the C++ Standard</h2>

<p>The Rock CMake macros use CMake's own mechanism to pick the C++ standard that should
be used to build the code. The template still picks the system's local default. If you
want to choose one explicitely, use (here for C++11)</p>

<div class="highlight"><pre class="highlight plaintext"><code>set(CMAKE_CXX_STANDARD 11)
</code></pre></div>
<p>This lets CMake use <em>at least</em> C++11 - some other dependencies might want a later
standard. If you want to have <em>exactly</em> C++11, add the following line</p>

<div class="highlight"><pre class="highlight plaintext"><code>set(CMAKE_CXX_STANDARD_REQUIRED 11)
</code></pre></div>
<p>The choice of the C++ standard is automatically
<a href="../components/orogen_packages.html#cxx_standard">propagated to oroGen projects</a> when developing components
based on a C++ library.</p>

<h2 id="package-dependencies">Package Dependencies</h2>

<p>It is common for packages to depend on other packages. All Rock-generated C++
packages for instance depend on <code>base/cmake</code>, which defines the
<a href="#rock-cmake-macros">Rock CMake helper macros</a>. Most of them also depend on
<code>base/types</code>, which define the common Rock datatypes.</p>

<p>Every time you want to add a new dependency to a C++ package, you need to
do <strong>two things</strong>:</p>

<ol>
  <li>update (the package's <code>manifest.xml</code>)[../workspace/add_packages.html#manifest_xml]
to declare the new dependency.</li>
  <li>update <code>src/CMakeLists.txt</code> to add the dependency to the package's targets.</li>
</ol>

<p>In the latter case, there are more than one modality for dependency resolution.
This is the beautiful world of C++ build systems after all.</p>

<p>If the other package defines a <code>pkg-config</code> file, add the name of its <code>.pc</code>
file to a <code>DEPS_PKGCONFIG</code> section, for instance</p>

<div class="highlight"><pre class="highlight plaintext"><code>rock_library(mylib
    DEPS_PKGCONFIG myahrs)
</code></pre></div>
<p>All Rock-generated packages define a pkg-config file using the package's basename
(i.e. <code>drivers/imu-myahrs</code> will have a <code>imu-myahrs</code> pkg-config file)</p>

<p>If the other package installs CMake dependency file, use the DEPS_CMAKE section</p>

<div class="highlight"><pre class="highlight plaintext"><code>rock_library(mylib
    DEPS_CMAKE cmakepkgname)
</code></pre></div>
<p>The name in <code>DEPS_CMAKE</code> is also dependent on the naming scheme of the other package.
Look for <code>*-config.cmake</code> or <code>Find*.cmake</code> in the package's prefix. The <code>*</code> is the
name you need to put in the <code>rock_library</code>, e.g. <code>FindGDAL.cmake</code> will be used by
<code>DEPS_CMAKE GDAL</code>.</p>

<p>Finally, if you create more than one target (library/executable) within your package,
you can define inter-dependencies</p>

<p>When using <code>DEPS_CMAKE</code> and <code>DEPS_PKGCONFIG</code>, you ensure that the dependencies
are saved in the generated pkg-config file (and therefore made available to
packages that would also depend on your package).</p>

<h2 id="unconventional_dependencies">Working around Unconventional 3rd Party Packages</h2>

<p>CMake has become de-facto standard in the C++ community as a build system, and
pkg-config is common (even if not universal) in the open source community.
However, there are still regular cases where there is support for neither means
to resolve a dependency.</p>

<p>Our recommendation in that case is to use autoproj to generate a pkg-config file
for said package on install. Writing a pkg-config file <em>for a given use case</em> is
relatively straightforward.</p>

<ol>
  <li>The hard part is to identity whether the library needs specific compiler and
linker flags. If it does, you also need to identify whether these flags will always
be present in your workspace's configuration.</li>
</ol>

<p>If they do (a common occurence), go to step 2.</p>

<p>Otherwise, the best way is to actually patch the package to make it generate a
pkg-config file for itself. How exactly you should do that is really beyond the
point of this documentation. It will heavily depend on the build system used by
the package.</p>

<ol>
  <li>Create a ERB template for the package's pkg-config file, and save it in the
package set. The file should be named <code>PACKAGE_BASENAME.pc.erb</code>, where PACKAGE_BASENAME
will be the name used by other package to refer to the dependency. For instance,
<a href="https://github.com/paullouisageneau/libdatachannel">libdatachannel</a>'s would be called
<code>libdatachannel.pc.erb</code>. A good starting point for this file is:</li>
</ol>

<p>```
includedir=&lt;%= pkg.prefix %&gt;/include
libdir=&lt;%= pkg.prefix %&gt;/lib</p>

<p>Name: <name_of_package>
Description: <description_of_package>
Version: <version_of_package>
Cflags: -I${includedir}
Libs: -L${libdir} -l<libname>
```</libname></version_of_package></description_of_package></name_of_package></p>

<ol>
  <li>Install the pkg-config file on package install. Modify the autobuild code that
defines the package to add something along the lines of:</li>
</ol>

<p><code>
cmake_package "tools/libdatachannel" do |pkg|
  pkg.post_install do
    template = ERB.new(File.read(File.join(__dir__, "libdatachannel.pc.erb")))
    pkgconfig = template.result(binding)
    pkgconfig_dir = File.join(pkg.prefix, "lib", "pkgconfig")
    FileUtils.mkdir_p pkgconfig_dir
    File.write(File.join(pkgconfig_dir, "libdatachannel.pc"), pkgconfig)
  end
end
</code></p>

<ol>
  <li>Run <code>amake --force PACKAGE</code> to install the new file</li>
  <li>Verify it is OK by re-sourcing the <code>env.sh</code> environment and running
<code>pkg-config --cflags PACKAGE</code> and <code>pkg-config --libs PACKAGE</code></li>
</ol>

<h2 id="conventions-for-library-design">Conventions for library design</h2>

<p>There's a small number of conventions that Rock libraries follow:</p>

<ul>
  <li><strong>Extensions</strong> header files are <code>.hpp</code>, source <code>.cpp</code></li>
  <li><strong>Naming</strong> classes should be <code>CamelCase</code>. The library must be defined under a
namespace that matches the package basename (e.g.
<code>imu_advanced_navigation_anpp</code> for <code>drivers/imu_advanced_navigation_anpp</code>). Each class
has its own file, with named like the class (i.e. the <code>Driver</code> class is in
<code>src/Driver.hpp</code> and <code>src/Driver.cpp</code>)</li>
  <li><strong>File Structure</strong> source and header files <em>tests excluded</em> are saved in
<code>src/</code>. Tests are in <code>test/</code>. When applicable, split unit tests following
the same structure than in <code>src/</code>, e.g. create <code>test/test_Spline.cpp</code> to
test the <code>Spline</code> class implemented in <code>src/Spline.(hpp|cpp)</code></li>
</ul>

<p>If the ultimate goal of a data type is to be used as an interface type on a
Rock component, you must take this into account when designing the type.
Read first <a href="../components/defining_types.html">the documentation on type definitions for components</a>.</p>

<h2 id="optional-features">Optional Features</h2>

<p>First rule of optional features is to keep optional features to a minimum.
Unless you are creating something of the size of OpenCV, they are not worth the
complexity.</p>

<p>The second rule of optional features is to avoid enabling or disabling them
based on auto-detection mechanism. These mechanisms are fragile, and will end up
being disabled for unknown reasons on a machine where they were expected to be
enabled, and vice-versa. Simply control their availability through a <a href="https://cmake.org/cmake/help/v3.0/command/option.html">CMake
option</a> and fail if the
feature is enabled but its dependencies are not present.</p>

<p>See also <a href="../workspace/managing.html#optional_features">this page</a> for a more
general discusssion on the subject.</p>

<h2 id="tests">Tests</h2>

<p>Testing is now an integral part of modern development process, and Rock
provides support to integrate unit testing in the development workflow.</p>

<p>The default library template creates a test suite that uses boost test. There
is also the possibility to use GTest and GMock, the Google-maintained C++
testing libraries.</p>

<p>To use GTest,</p>

<ol>
  <li>
    <p>modify the package's <code>manifest.xml</code> to add</p>

<div class="highlight"><pre class="highlight xml"><code><span class="nt">&lt;test_depend</span> <span class="na">package=</span><span class="s">"google-test"</span> <span class="nt">/&gt;</span>
</code></pre></div>  </li>
  <li>replace <a href="#rock_testsuite"><code>rock_testsuite</code></a> in <code>test/CMakeLists.txt</code> by <a href="#rock_gtest"><code>rock_gtest</code></a>,</li>
  <li>
    <p>and replace the content of <code>test/suite.cpp</code> with the following:</p>

<div class="highlight"><pre class="highlight cpp"><code><span class="c1">// Do NOT add anything to this file</span>
<span class="cp">#include</span> <span class="cpf">&lt;gtest/gtest.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InitGoogleTest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">RUN_ALL_TESTS</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>  </li>
</ol>

<p>All C++ libraries that have a <code>test/</code> folder will be assumed to have a test suite.
However, testing is disabled by default - since building all the tests from all
the workspace's packages would be fairly expensive. One needs to enable a package
tests to build them:</p>

<div class="highlight"><pre class="highlight plaintext"><code>acd package/name
autoproj test enable .
aup
amake
</code></pre></div>
<p>The <code>aup</code> step is needed if the package has test-specific dependencies, as
defined by the <code>test_depend</code> tag of its <a href="../workspace/add_packages.html#manifest_xml">manifest
file</a>.</p>

<p>Once the tests are built, run them manually if you want to see their results.
Autoproj can also run them with <code>autoproj test [package]</code>, but will redirect
the test's output to a log file (that can be visualized later with
<a href="../basics/day_to_day.html#alog">alog</a>).</p>

<h2 id="debugging-in-vscode">Debugging in VSCode</h2>

<p>When within a C++ package, the <code>rock - Add launch config</code> command will help
you with selecting the binary you want to run. It discovers binaries within
the package's build directory and proposes them to add to the new
configuration. The equivalent functionality is available through the "Add Entry"
button when editing an existing <code>launch.json</code> file.</p>

<p><strong>NOTE</strong> due to a bug in VSCode, newly created <code>launch.json</code> files are
sometimes not taken into account. If this is the case, you have to reload
VSCode with the <code>Reload Window</code> command.</p>

<p>Click on the image below for a demo video:</p>

<p><a href="https://www.youtube.com/watch?v=1bJx2UYKf1c"><img src="https://img.youtube.com/vi/1bJx2UYKf1c/0.jpg" alt="Demo workflow fo C++ packages" /></a></p>

<p>The generated C++ launch configurations are <a href="https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md">standard cppdbg launch
configurations</a>.
To ease integration within an autoproj workspace, the extension provides the
possibility to use expansions to query information about the autoproj
environment. These expansions can be used in any field within the debug
configuration.</p>

<ul>
  <li><code>${rock:srcDir}</code> expands to the package's source directory</li>
  <li><code>${rock:buildDir}</code> expands to the package's build directory. You usually
will need this to resolve programs or files that are not installed by the
package, such as test programs.</li>
  <li><code>${rock:prefixDir}</code> expands to the package's prefix (install) directory. You
will need this to resolve path to files installed by the package.</li>
  <li><code>${rock:which:cmd}</code> expands to the full path to the command <code>cmd</code> within
 the autoproj workspace's PATH. Use this to resolve programs that are
 installed by the packages.</li>
</ul>

<h2 id="rock-cmake-macros">The Rock CMake macros</h2>

<p>To ease the use of CMake within a Rock system - i.e. in packages that follow
Rock conventions, Rock provides CMake macros that are somewhat easier to use.
The following describes them. The macros can be found in
<code>base/cmake/modules/Rock.cmake</code> in a rock installation.</p>

<p><strong>Note</strong> the Rock CMake macros are only dependent on files present in the
CMake distribution, and with pkg-config. These are all standard tools, and as such
using the Rock CMake macros in a package adds only the (very minimal)
dependency on the <code>base/cmake</code> package itself. It will need nothing else
within Rock, and definitely nothing from Autoproj itself.</p>

<h2 id="using-rocks-text-logger">Using Rock's text logger</h2>

<p>Rock provides a logger that facilitates and unifies
debugging of system libraries. The following section
describes the functionality of the base logger and how to
use it.</p>

<p>When using the Rock CMake Macros, integration of the base logger is fairly
easy.  All you need to do is adding <em>base-logging to your list of package config
dependencies and include the header _base/logging/Logging.hpp</em> where logging is needed.</p>

<div class="highlight"><pre class="highlight plaintext"><code>rock_library(test_library
         DEPS_PKGCONFIG base-logging
         ...)
</code></pre></div>
<p>and</p>

<div class="highlight"><pre class="highlight plaintext"><code>#include &lt;base-logging/Logging.hpp&gt;
</code></pre></div>
<p>The logger allows you to log either using a printf-style function, or
stream-style.</p>

<div class="highlight"><pre class="highlight cpp"><code><span class="cp">#include</span> <span class="cpf">&lt;base-logging/Logging.hpp&gt;</span><span class="cp">
</span>
<span class="p">...</span>
<span class="c1">// printf-style logging</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">information</span><span class="p">(</span><span class="s">"test-logging happening here"</span><span class="p">);</span>
<span class="n">LOG_DEBUG</span><span class="p">(</span><span class="s">"I provide you the following debug information: %s"</span><span class="p">,</span>
    <span class="n">information</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="n">LOG_INFO</span><span class="p">(...);</span>
<span class="n">LOG_WARN</span><span class="p">(...);</span>
<span class="n">LOG_ERROR</span><span class="p">(..);</span>
<span class="n">LOG_FATAL</span><span class="p">(..);</span>

<span class="c1">// stream-style logging</span>
<span class="n">LOG_DEBUG_S</span> <span class="o">&lt;&lt;</span> <span class="n">information</span><span class="p">;</span>
<span class="n">LOG_INFO_S</span> <span class="o">&lt;&lt;</span> <span class="n">information</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">LOG_FATAL</span> <span class="o">&lt;&lt;</span> <span class="n">information</span><span class="p">;</span>
</code></pre></div>
<p>The default output format of a log message looks like the following (without linebreak):</p>

<div class="highlight"><pre class="highlight plaintext"><code>[20120120-11:58:00:577] [FATAL] - test_logger::A fatal error occurred (/tmp/test_logger/src/Main.cpp:10 - int main(int, char**))
</code></pre></div>
<p>The logger can be configured at compile time to remove unwanted logging
statement in a release version, and at runtime to control the verbosity level
and logging format.</p>

<p><strong>At compile time</strong>, the following defines can be set to configure the logger:</p>

<ul>
  <li><strong>BASE_LOG_NAMESPACE</strong> a string that will be displayed in all log messages.
Set it to a unique string that allows you to filter the logging output. The
Rock CMake macros set it to the package name.</li>
  <li><strong>BASE_LOG_DISABLE</strong> set to ON to deactivates all logging statements, e.g.
for a realease binary.</li>
  <li><strong>BASE_LOG_xxx</strong> compile only logs equal or higher than a certain level xxx
into your binary, i.e. BASE_LOG_WARN disable all logs except for WARN, ERROR
and FATAL. Since the remaining levels are compiled out, the runtime settings
below will be limited to the remaining levels.</li>
  <li><strong>BASE_LONG_NAMES</strong> set this define in order to enforce a BASE_ prefix for
the logging Macros, to avoid clashes with other libraries, i.e.
BASE_LOG_DEBUG(…)</li>
</ul>

<p><strong>At runtime</strong>, the following environment variables can be used to control the behaviour of the logger:</p>

<ul>
  <li><strong>BASE_LOG_LEVEL</strong> Set to one of DEBUG, INFO, WARN, ERROR or FATAL to define
the maximum logging level, e.g. export BASE_LOG_LEVEL="DEBUG"</li>
  <li><strong>BASE_LOG_COLOR</strong> Activate colored logging (current configuration best for
dark background coloured terminals), e.g. export BASE_LOG_COLOR</li>
  <li><strong>BASE_LOG_FORMAT</strong> Select from a set of predefined logging formats: DEFAULT,
MULTILINE, SHORT, example outputs are given below:</li>
</ul>

<p>The DEFAULT format contains no linebreaks (here only due to fit the narrow presentation):</p>

<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>20120120-11:58:00:577] <span class="o">[</span>FATAL] - test_logger::A fatal error
occurred <span class="o">(</span>/tmp/test_logger/src/Main.cpp:10 - int main<span class="o">(</span>int, char<span class="k">**</span><span class="o">))</span>
</code></pre></div>
<p>The SHORT format reduces information to the log priority and the message:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>FATAL] - test_logger::A fatal error occurred
</code></pre></div>
<p>The MULTILINE format split each individual log message across a minimum of three lines:</p>

<div class="highlight"><pre class="highlight shell"><code><span class="o">[</span>20120120-11:58:59:976] <span class="k">in </span>int main<span class="o">(</span>int, char<span class="k">**</span><span class="o">)</span>
        /tmp/test_logger/src/Main.cpp:10
        <span class="o">[</span>FATAL] - test_logger::A fatal error occurred
</code></pre></div>
<p class="next-page">The end of this section will detail the CMake macros. Unless you need them, you may
want to go to the next topic: <a href="ruby_libraries.html">the integration of Ruby packages</a></p>

<h2 id="rockcmake-reference-documentation">Rock.cmake Reference Documentation</h2>

<h3 id="executable-targets-rockexecutable">Executable Targets (<code>rock_executable</code>)</h3>

<div class="highlight"><pre class="highlight plaintext"><code>rock_executable(name
    SOURCES source.cpp source1.cpp ...
    [LANG_C]
    [DEPS target1 target2 target3]
    [DEPS_PKGCONFIG pkg1 pkg2 pkg3]
    [DEPS_CMAKE pkg1 pkg2 pkg3]
    [MOC qtsource1.hpp qtsource2.hpp])
</code></pre></div>
<p>Creates a C++ executable and (optionally) installs it.</p>

<p>The following arguments are mandatory:</p>

<p><strong>SOURCES</strong>: list of the C++ sources that should be built into that library</p>

<p>The following optional arguments are available:</p>

<p><strong>LANG_C</strong>: build as a C rather than a C++ library</p>

<p><strong>DEPS</strong>: lists the other targets from this CMake project against which the
library should be linked</p>

<p><strong>DEPS_PKGCONFIG</strong>: list of pkg-config packages that the library depends upon. The
necessary link and compilation flags are added</p>

<p><strong>DEPS_CMAKE</strong>: list of packages which can be found with CMake's find_package,
that the library depends upon. It is assumed that the Find*.cmake scripts
follow the CMake accepted standard for variable naming</p>

<p><strong>MOC</strong>: if the library is Qt-based, this is a list of either source or header
files of classes that need to be passed through Qt's moc compiler.  If headers
are listed, these headers should be processed by moc, with the resulting
implementation files are built into the library. If they are source files, they
get added to the library and the corresponding header file is passed to moc.</p>

<h3 id="library-targets-rocklibrary">Library Targets (<code>rock_library</code>)</h3>

<div class="highlight"><pre class="highlight plaintext"><code>rock_library(name
    [SOURCES source.cpp source1.cpp ...]
    [HEADERS header1.hpp header2.hpp header3.hpp ...]
    [LANG_C]
    [DEPS target1 target2 target3]
    [DEPS_PKGCONFIG pkg1 pkg2 pkg3]
    [DEPS_CMAKE pkg1 pkg2 pkg3]
    [MOC qtsource1.hpp qtsource2.hpp]
    [NOINSTALL])
</code></pre></div>
<p>Creates and (optionally) installs a shared library.</p>

<p>As with all rock libraries, the target must have a pkg-config file along, that
gets generated and (optionally) installed by the macro. The pkg-config file
needs to be in the same directory and called package_name.pc.in. See the template
created by <code>rock-create-lib</code> for an example.</p>

<p>The following arguments are mandatory:</p>

<p><strong>SOURCES</strong>: list of the C++ sources that should be built into that library. If
absent, the library is assumed to be header-only (i.e. only the headers and
pkg-config file will be installed). Note that even in this case the DEPS_* arguments
can be provided as they are passed to the pkg-config file generation.</p>

<p><strong>HEADERS</strong>: list of the C++ headers that should be installed. Headers are installed
in <code>include/&lt;target_name&gt;/</code>.</p>

<p>The following optional arguments are available:</p>

<p><strong>LANG_C</strong>: build as a C rather than a C++ library</p>

<p><strong>DEPS</strong>: lists the other targets from this CMake project against which the
library should be linked</p>

<p><strong>DEPS_PKGCONFIG</strong>: list of pkg-config packages that the library depends upon. The
necessary link and compilation flags are added</p>

<p><strong>DEPS_CMAKE</strong>: list of packages which can be found with CMake's find_package,
that the library depends upon. It is assumed that the Find*.cmake scripts
follow the CMake accepted standard for variable naming</p>

<p><strong>MOC</strong>: if the library is Qt-based, this is a list of either source or header
files of classes that need to be passed through Qt's moc compiler.  If headers
are listed, these headers should be processed by moc, with the resulting
implementation files are built into the library. If they are source files, they
get added to the library and the corresponding header file is passed to moc.</p>

<p><strong>NOINSTALL</strong>: by default, the library gets installed on 'make install'. If this
argument is given, this is turned off</p>

<h3 id="rock_testsuite">Boost Test Suite Targets (<code>rock_testsuite</code>)</h3>

<div class="highlight"><pre class="highlight plaintext"><code>rock_testsuite(name
    SOURCES source.cpp source1.cpp ...
    [LANG_C]
    [DEPS target1 target2 target3]
    [DEPS_PKGCONFIG pkg1 pkg2 pkg3]
    [DEPS_CMAKE pkg1 pkg2 pkg3]
    [MOC qtsource1.hpp qtsource2.hpp])
</code></pre></div>
<p>Creates a C++ test suite that is using the boost unit test framework</p>

<p>The following arguments are mandatory:</p>

<p><strong>SOURCES</strong>: list of the C++ sources that should be built into that library</p>

<p>The following optional arguments are available:</p>

<p><strong>LANG_C</strong>: build as a C rather than a C++ library</p>

<p><strong>DEPS</strong>: lists the other targets from this CMake project against which the
library should be linked</p>

<p><strong>DEPS_PKGCONFIG</strong>: list of pkg-config packages that the library depends upon. The
necessary link and compilation flags are added</p>

<p><strong>DEPS_CMAKE</strong>: list of packages which can be found with CMake's find_package,
that the library depends upon. It is assumed that the Find*.cmake scripts
follow the CMake accepted standard for variable naming</p>

<p><strong>MOC</strong>: if the library is Qt-based, this is a list of either source or header
files of classes that need to be passed through Qt's moc compiler.  If headers
are listed, these headers should be processed by moc, with the resulting
implementation files are built into the library. If they are source files, they
get added to the library and the corresponding header file is passed to moc.</p>

<h3 id="rock_gtest">GTest Test Suite Targets (<code>rock_gtest</code>)</h3>

<div class="highlight"><pre class="highlight plaintext"><code>rock_gtest(name
    SOURCES source.cpp source1.cpp ...
    [LANG_C]
    [DEPS target1 target2 target3]
    [DEPS_PKGCONFIG pkg1 pkg2 pkg3]
    [DEPS_CMAKE pkg1 pkg2 pkg3]
    [MOC qtsource1.hpp qtsource2.hpp])
</code></pre></div>
<p>Creates a C++ test suite that is using the Google unit test framework</p>

<p>The following arguments are mandatory:</p>

<p><strong>SOURCES</strong>: list of the C++ sources that should be built into that library</p>

<p>The following optional arguments are available:</p>

<p><strong>LANG_C</strong>: build as a C rather than a C++ library</p>

<p><strong>DEPS</strong>: lists the other targets from this CMake project against which the
library should be linked</p>

<p><strong>DEPS_PKGCONFIG</strong>: list of pkg-config packages that the library depends upon. The
necessary link and compilation flags are added</p>

<p><strong>DEPS_CMAKE</strong>: list of packages which can be found with CMake's find_package,
that the library depends upon. It is assumed that the Find*.cmake scripts
follow the CMake accepted standard for variable naming</p>

<p><strong>MOC</strong>: if the library is Qt-based, this is a list of either source or header
files of classes that need to be passed through Qt's moc compiler.  If headers
are listed, these headers should be processed by moc, with the resulting
implementation files are built into the library. If they are source files, they
get added to the library and the corresponding header file is passed to moc.</p>

<p><strong>Next</strong> let's look at the creation of <a href="ruby_libraries.html">ruby packages</a></p>

            </div>
        </div>
    </div>

    <script>
    $('.docs-sidebar').affix({
        offset: {
            top: $('.docs-sidebar').offset().top
        }
    });
    </script>


        <footer class="container-fluid text-center">
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Building Robots with Rock and Syskit</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/doudou" property="cc:attributionName" rel="cc:attributionURL">Sylvain Joyeux</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. Copyright Sylvain Joyeux and Contributors
        </footer>
    </body>
</html>
