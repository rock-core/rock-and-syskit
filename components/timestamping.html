<!DOCTYPE html>
<html lang="en">
    <head>
        <meta content="IE=edge" http-equiv="X-UA-Compatible">
        <meta charset="utf-8">
        <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Building Robots with Rock and Syskit</title>

        <link href="../images/favicon.ico" rel="icon" type="image/ico" relative="true" />
        <link href="../stylesheets/site.css" rel="stylesheet" />
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    </head>

    <body class="components components_timestamping">
            <!-- top navbar -->
    <nav class="navbar navbar-inverse">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">
                    <li><a href="../">Home</a></li>
                    <li><a href="../about.html">About</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3" role="complementary">
                <nav class="docs-sidebar" data-spy="affix">
                    <ul class="nav"><li class='child'><a href="../">Building robots with Rock and Syskit</a></li><li class='parent'><span class='parent-label'><a href="../basics/">Basics</a></span><ul><li class='child'><a href="../basics/">Introduction</a></li><li class='child'><a href="../basics/installation.html">Installation</a></li><li class='child'><a href="../basics/day_to_day.html">Day-to-day Workspace Commands</a></li><li class='child'><a href="../basics/getting_started.html">Getting Started</a></li><li class='child'><a href="../basics/composition.html">Compositions</a></li><li class='child'><a href="../basics/constant_generator.html">Constant Generator</a></li><li class='child'><a href="../basics/devices.html">Profiles and Devices</a></li><li class='child'><a href="../basics/deployment.html">Deployment</a></li><li class='child'><a href="../basics/publishing.html">Publishing</a></li><li class='child'><a href="../basics/validation.html">Configuration Consistency</a></li><li class='child'><a href="../basics/recap.html">Recap</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../runtime_overview/">Runtime Overview</a></span><ul><li class='child'><a href="../runtime_overview/">Introduction</a></li><li class='child'><a href="../runtime_overview/task_structure.html">Task Structures</a></li><li class='child'><a href="../runtime_overview/event_loop.html">Event Loop</a></li><li class='child'><a href="../runtime_overview/exceptions.html">Errors</a></li><li class='child'><a href="../runtime_overview/live_data.html">Live Data Visualization</a></li><li class='child'><a href="../runtime_overview/recap.html">Recap</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../workspace/">Workspace and Packages</a></span><ul><li class='child'><a href="../workspace/">Introduction</a></li><li class='child'><a href="../workspace/conventions.html">Conventions</a></li><li class='child'><a href="../workspace/setup.html">Starting a New Project</a></li><li class='child'><a href="../workspace/add_packages.html">Adding new packages</a></li><li class='child'><a href="../workspace/os_dependencies.html">OS Dependencies</a></li><li class='child'><a href="../workspace/global_configuration.html">Global Configuration</a></li><li class='child'><a href="../workspace/testing.html">Test Integration</a></li><li class='child'><a href="../workspace/managing.html">Build configuration design</a></li><li class='child'><a href="../workspace/troubleshooting.html">Troubleshooting</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../libraries/">Libraries</a></span><ul><li class='child'><a href="../libraries/">Introduction</a></li><li class='child'><a href="../libraries/add_packages.html">Add packages</a></li><li class='child'><a href="../libraries/cpp_libraries.html">C++ Library Packages</a></li><li class='child'><a href="../libraries/geometric_transformations.html">Geometric Transformations in C++ Libraries</a></li><li class='child'><a href="../libraries/ruby_libraries.html">Ruby Library Packages</a></li></ul></li><li class='parent active'><span class='parent-label'><a href="./">Components</a></span><ul><li class='child'><a href="./">Writing Components</a></li><li class='child'><a href="orogen_packages.html">oroGen Packages</a></li><li class='child'><a href="defining_types.html">Defining Types</a></li><li class='child'><a href="importing_types.html">Importing Types</a></li><li class='child'><a href="interface.html">Interface</a></li><li class='child'><a href="state_machine.html">State Machine</a></li><li class='child'><a href="writing_the_hooks.html">Writing the Hooks</a></li><li class='child active'><a href="timestamping.html">Timestamping</a></li><li class='child'><a href="stream_aligner.html">Stream Aligner</a></li><li class='child'><a href="geometric_transformations.html">Geometric Transformations</a></li><li class='child'><a href="deployment.html">Deployments</a></li><li class='child'><a href="runtime.html">Runtime</a></li><li class='child'><a href="testing.html">Testing</a></li><li class='child'><a href="types_in_ruby.html">Types in Ruby</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../component_networks/">Designing Component Networks</a></span><ul><li class='child'><a href="../component_networks/">Introduction</a></li><li class='child'><a href="../component_networks/composition.html">Compositions</a></li><li class='child'><a href="../component_networks/profiles.html">Profiles</a></li><li class='child'><a href="../component_networks/reusable_networks.html">Reusable Networks</a></li><li class='child'><a href="../component_networks/devices_and_busses.html">Robot definition&colon; Devices and Busses</a></li><li class='child'><a href="../component_networks/dynamic_services.html">Dynamic Services</a></li><li class='child'><a href="../component_networks/geometric_transformations.html">Geometric Transformations</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../coordination/">Coordination</a></span><ul><li class='child'><a href="../coordination/">Introduction</a></li><li class='child'><a href="../coordination/generalities.html">Generalities</a></li><li class='child'><a href="../coordination/tasks_and_events.html">Tasks and Events</a></li><li class='child'><a href="../coordination/action_methods.html">Action Methods</a></li><li class='child'><a href="../coordination/action_state_machines.html">Action State Machines</a></li><li class='child'><a href="../coordination/component_networks.html">Component Networks</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../simulation/">Simulation with Gazebo</a></span><ul><li class='child'><a href="../simulation/">Introduction</a></li><li class='child'><a href="../simulation/models_links_and_joints.html">Models, Links, Joints and Sensors</a></li><li class='child'><a href="../simulation/plugins.html">Plugins</a></li><li class='child'><a href="../simulation/transformer.html">Transformer</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../syskit_error_handling/">Error Handling</a></span><ul><li class='child'><a href="../syskit_error_handling/">Introduction</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../log_management/">Log Management</a></span><ul><li class='child'><a href="../log_management/">Introduction</a></li><li class='child'><a href="../log_management/runtime.html">Log Generation at Runtime</a></li><li class='child'><a href="../log_management/datastore.html">Storing Logs</a></li><li class='child'><a href="../log_management/jupyter.html">Log Analysis with Jupyter</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../testing/">Testing and Debugging</a></span><ul><li class='child'><a href="../testing/">Introduction</a></li><li class='child'><a href="../testing/component.html">Component Tests</a></li><li class='child'><a href="../testing/integration.html">Integration Tests</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../cookbook/">Cookbook</a></span><ul><li class='child'><a href="../cookbook/">Introduction</a></li><li class='child'><a href="../cookbook/device_drivers.html">Device Drivers with iodrivers_base</a></li><li class='child'><a href="../cookbook/http_api.html">Control and Monitoring through a HTTP API</a></li></ul></li><li class='parent'><span class='parent-label'><a href="../deprecations/">Deprecated Behaviors</a></span><ul><li class='child'><a href="../deprecations/">Introduction</a></li><li class='child'><a href="../deprecations/backward_compatible_naming.html">Backward compatible naming</a></li><li class='child'><a href="../deprecations/update_properties.html">Introduction of the `update_properties` method</a></li></ul></li></ul>
                </nav>
            </div>
            <div class="col-md-9" role="main">
                <h1 class="no_toc" id="data-and-timestamps">Data and Timestamps</h1>

<ul id="markdown-toc">
  <li><a href="#timestamping" id="markdown-toc-timestamping">Timestamping</a></li>
  <li><a href="#estimating-and-improving-acquisition-timestamps" id="markdown-toc-estimating-and-improving-acquisition-timestamps">Estimating and Improving Acquisition Timestamps</a></li>
  <li><a href="#timestamps-in-rock-data-types" id="markdown-toc-timestamps-in-rock-data-types">Timestamps in Rock data types</a></li>
  <li><a href="#timestamp_estimator" id="markdown-toc-timestamp_estimator">Filtering Latency with the Timestamp Estimator</a></li>
</ul>

<p>One major design difference between component systems commonly found in the software
engineering community and the ones developed by the robotics community is that, in the
former, interaction between components is mostly done through messaging and protocols
(synchronous or asynchronous RPC) while, in the second one, the dominant model is the one
of dataflow (one-way transmission of data samples). The main reason for that difference is
that the consensus in the robotics community is to see the component layer as a data
processing layer, i.e. a set of mingled pipelines in which data flows and gets
processed, while the software engineering community is more focussed on business
processes, in which transmission of information needs to be done through two-way protocols.</p>

<p>In other words: in robotics, when it comes to develop components, <em>data is king</em>. The
major implication of that, when one develops a robotic toolchain, is that both tools and
components need to be designed so as to handle the issue raising with data, originating
from the world and being processed in an asynchronous way <em>but in realtime</em>.</p>

<p>This has a lot of ramifications. We will deal with in this page with the one that has
the most impact on writing libraries and components for the robotics world:
<em>timestamping</em>.  A related issue, the one of time-ordered data processing, will
be dealt with <a href="stream_aligner.html">in our presentation of the stream aligner</a>.</p>

<h2 id="timestamping">Timestamping</h2>

<p>Since robotics is all about managing physical systems that evolve in a physical
environment, and modify it, the relationship between the data that are being processed and
this environment is central to the problem of data processing. Key to that is the ability
to associate data temporally: the ability to mark when a particular information was
sensed from the physical world. This process is usually referred as <em>timestamping</em>.</p>

<p>In the following example, since the two data acquisition pipelines have
(tremendously) different processing times, the point cloud generated from the
stereo pair and the IMU readings <em>that have originate from the same point in
time in the real world</em> are going to reach the pose estimator component at very
different times. It is therefore important for the pose estimation component to
be able to know their actual order <em>in the real world</em>. This is what data
timestamping is meant to achieve: not mark when a particular data structure has
been filled, but when the information contained in this data structure was
sensed in the real world.</p>

<p><img src="media/timestamping.svg" alt="Time in a processing graph" class="fullwidth" /></p>

<p>Moreover, at the output of the pose estimator, the generated pose should also be
timestamped properly, i.e. mark the time at which the pose estimate was the pose
of the robot <em>in the real world</em>. Most estimation algorithms do provide this information
(they provide a timestamped best estimate).</p>

<p>It is unfortunately a not so well understood issue. Indeed, a recurrent idea is
that the framework itself could timestamp data. Which it could, but only if it
had a model of how information propagates through the components – something
that to our knowledge none of the mainstream frameworks does.</p>

<p>From an abstract point of view, the main guidelines about timestamps are:</p>

<ul>
  <li>not having a timestamp in a data stream should be the exception, not the norm</li>
  <li>for a data sample, the timestamp represents the time at which the data was
valid <em>in the real world</em>. In simple processing pipelines, the timestamp of the
output is usually the timestamp of the processed input. Withing data fusion,
the fusion   algorithm usually tell us what's the timestamp (e.g. a Kalman
filter produces the best estimate for the sample received at the last update
step).</li>
  <li>control samples are a different matter. A good timestamp would general
timestamp would be the time of the feedback that was used to generate the
control sample. Pipelines should propagate the timestamp. This provides
a measurement of the latency of the whole loop, which is a critical aspect.</li>
</ul>

<h2 id="estimating-and-improving-acquisition-timestamps">Estimating and Improving Acquisition Timestamps</h2>

<p>Let's look at a standard data acquisition process in a robotic system. As we
already stated, our goal is to estimate, as closely as possible, <em>when</em> the
data has been acquired by the sensor. Assuming a system with four sensors: an
IMU, a laser scanner and two cameras (for the purpose of explaining the
timestamping process, only the IMU will be used).</p>

<p>Ideally, timestamping would match the sensor acquisition times:</p>

<p><img src="media/timeline_sensor_acquisition.svg" alt="Ideal timestamps" class="fullwidth" /></p>

<p>However, timestamping the data that originates from the sensors is a task that
is hindered by phenomenons in the data acquisition chain: sensor acquisition
process, communication between the sensor and the CPU, operating system
scheduling (when the driver process gets executed once the data arrived) and –
last but not least – clock synchronization in multi-CPU (and therefore
multi-robot) systems.  Fortunately for us, a few of these can be estimated
offline and/or online.</p>

<p>This estimation of the time difference between an event and when this event is
measured is commonly separated between a mean <em>latency</em> (constant part)
and a <em>jitter</em> (variability).</p>

<p><img src="media/timeline_driver_component.svg" alt="Latency and jitter" class="fullwidth" /></p>

<p>Since most sensors have a fixed acquisition period, the jitter can be filtered
out over time by estimating the average sensor period and base time. In Rock,
this is done by the <code>aggregator::TimestampEstimator</code> class <a href="#timestamp_estimator">that is
described later on this page</a></p>

<p>The average latency, however, is a different issue altogether. It
originates from different sources, each of which have to be solved by different
means:</p>

<p><strong>Sensor</strong> the latency in the sensor acquisition process is usually documented (or
can at least be informally given by the company producing this sensor). In case of sensors
developed in-house, this value can be estimated.</p>

<p><strong>Communication layer</strong> a rough estimate can usually be obtained by looking at the
amount of data and the communication layer bandwidth.</p>

<p><strong>Operating system</strong> is the weak part of the chain if one does not use a
hard-realtime operating system such as Xenomai or QNX <em>or</em> has devices that are
not compatible with that realtime operating system. However, some communication layers timestamp
messages at the driver level (for instance, CAN and firewire stacks on Linux systems). For other layers, no
information can be obtained directly.</p>

<p><strong>Clock synchronization</strong> clock synchronization solutions like NTP are available
to synchronize multiple CPUs. However, they take long to converge, especially over
wireless networks (if they converge at all), making it practical only on systems that are
up most of the time. Additionally to NTP, outdoors, one can use GPS as a time source.
Indoors, no really good solution exist to our knowledge.</p>

<p><strong>Throwing hardware at the task</strong> It became common for sensors used in robotic
applications to have so-called hardware synchronization signals that announce a particular event (for instance,
start of acquisition), or hardware triggers that allow to pick the point of acquisition
(common on cameras). Using adapted hardware and combined with the techniques proposed
above, this method allows to achieve data timestamping of the order of one milliseconds,
regardless of the operating system properties. The TimestampEstimator class also
accepts a separate stream of timestamps that it is using to estimate the
latency. Check out the next page for details.</p>

<h2 id="timestamps-in-rock-data-types">Timestamps in Rock data types</h2>

<p>Timestamped data samples within Rock's base types are all defined within the
<code>/base/samples</code> namespace, and provide a first field called <code>time</code> of type
<code>/base/Time</code>. For historical reasons, commands are usually not timestamped. Do
add one following the same When applicable (that is, mostly all the time), the
Rock data types</p>

<h2 id="timestamp_estimator">Filtering Latency with the Timestamp Estimator</h2>

<p>The TimestampEstimator class, which lies in the aggregator package, is used to
remove the jitter out of a periodic time stream. Basically, once configured, one
gives it a time in a time series that (1) is periodic (2) can (rarely) contain
lost samples and/or bursts, and returns the best estimate for the provided
time.</p>

<p>One design criteria for this class is that it has to be zero-latency, i.e. the
timestamp estimator never delays the processing of a sample.</p>

<p>To use it, one first adds the aggregator package in the list of dependencies
and adds the corresponding <code>using_library</code> statement in the orogen file.  In
addition, in order to track how the filter behaves, one should create in
addition a status port, on which estimation-related statistics are output:</p>

<p>The <code>manifest.xml</code>:</p>

<div class="highlight"><pre class="highlight xml"><code><span class="nt">&lt;depends</span> <span class="na">package=</span><span class="s">"drivers/orogen/aggregator"</span> <span class="nt">/&gt;</span>
</code></pre></div>
<p>In the toplevel of the orogen file:</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">using_library</span> <span class="s2">"aggregator"</span>
<span class="n">import_types_from</span> <span class="s2">"aggregator"</span>
</code></pre></div>
<p>An in the <code>task_context</code> definitions:</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">output_port</span> <span class="s1">'timestamp_estimator_status'</span><span class="p">,</span>
  <span class="s1">'/aggregator/TimestampEstimatorStatus'</span>
</code></pre></div>
<p>On the C++ side, one declares an <code>aggregator::TimestampEstimator</code> instance
variable in the task's header (not forgetting to include
<code>aggregator/TimestampEstimator.hpp</code>). This object will be configured in
<code>configureHook</code> and reset in the <code>startHook</code>.</p>

<p>At creation time, only one parameters is required: the estimation window. The
timestamp estimator continuously estimates the device period by averaging the
duration between successive samples on a certain time window. For stability
reasons, that time window should be chosen pretty big (~ 100 periods or more).
If your device period is known to drift, you should choose a window that is at
most 10% of any significant drift time (i.e. if the period changes more than
10% after 10s, the window should be at most 1s)</p>

<p>Additionally, it is recommended to provide the expected device period. At
initialization, the estimator does not have any information about the time
stream it has to estimate, which makes it initially very sensible to jitter
(i.e. the estimated times will be pretty bad). Providing an expected period –
which is usually available from the device type and configuration – improves
the initial estimation quite a lot.</p>

<p>As an example, the setup of the Xsens IMU, when configured at 10Hz, would be:</p>

<div class="highlight"><pre class="highlight cpp"><code><span class="n">mTimestamper</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">::</span><span class="n">TimestampEstimator</span><span class="p">(</span>
    <span class="n">base</span><span class="o">::</span><span class="n">Time</span><span class="o">::</span><span class="n">fromSeconds</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">base</span><span class="o">::</span><span class="n">Time</span><span class="o">::</span><span class="n">fromMilliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</code></pre></div>
<p>Then, in the updateHook, one gets its best estimate with:</p>

<div class="highlight"><pre class="highlight cpp"><code><span class="n">data</span> <span class="o">=</span> <span class="n">mDriver</span><span class="o">-&gt;</span><span class="n">getSample</span><span class="p">();</span>
<span class="n">data</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">mTimestamper</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">time</span><span class="p">);</span>
<span class="n">_timestamp_estimator_status</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">mTimestamper</span><span class="p">.</span><span class="n">getStatus</span><span class="p">());</span>
</code></pre></div>
<p>Do <strong>not</strong> forget to reset the estimator in the startHook</p>

<div class="highlight"><pre class="highlight cpp"><code><span class="n">mTimestamper</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</code></pre></div>
<p>All is well and good for now … as long as no samples get lost or unexpectedly
delayed.  The main issue here being that delayed samples look very much – from
the point of view of the estimator – like lost samples.</p>

<p>Let's take our IMU, and see a realistic case for latency and jitter during execution:</p>

<p><img src="media/timeline_driver_component.svg" alt="Latency and jitter" class="fullwidth" /></p>

<p>In this example, when the component receives sample 3, how can it know whether it <strong>is</strong> sample
3 or sample 4 ? Indeed, sample 3 is received <strong>after</strong> the expected minimum
reception time of sample 4, so it could either be sample 4 early or sample
3 very late.</p>

<p>In case of actual bursts (i.e. when the component receives multiple samples at
once), the same issue arises: since the estimator is not allowed by design to
store samples.</p>

<p><img src="media/timeline_driver_component_bursts.svg" alt="Bursts" class="fullwidth" /></p>

<p>This situation can ideally be solved by indexes provided by the sensor. Some
sensors count how many samples it generated so far and provides this information
<strong>inside the data stream itself</strong>. In this case, this index can be explicitly
provided to the estimator (<strong>you have to be careful about wraparounds</strong>).</p>

<div class="highlight"><pre class="highlight cpp"><code><span class="n">data</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">mTimestamper</span><span class="p">.</span><span class="n">update</span><span class="p">(</span>
  <span class="n">data</span><span class="p">.</span><span class="n">time</span><span class="p">,</span> <span class="n">mDriver</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">());</span>
</code></pre></div>
<p>Finally, if you have a mean to determine data loss other than the index, you can
announce lost samples to the estimator:</p>

<div class="highlight"><pre class="highlight cpp"><code><span class="n">mTimestamper</span><span class="p">.</span><span class="n">updateLoss</span><span class="p">();</span>
</code></pre></div>
<p>If no external means to determine loss is available, the estimator itself has a
threshold-based mechanism to choose between the lost sample case or the delayed
sample case. The last parameter of the constructor provides a loss_limit number
of periods:</p>

<ul>
  <li>if a sample i+1 is received and t(i+1) - t(i) &lt;= P*loss_limit, then the
estimator will think that the sample has been delayed</li>
  <li>if a sample i+1 is received and t(i+1) - t(i) &gt; P*loss_limit, then the
estimator will think that one sample has been lost.</li>
</ul>

<p>The loss threshold is provided as the third argument to the constructor. It is
recommended to define a property called <code>sample_loss_threshold</code> of type <code>/int</code>
to give some control over this option. The default value for it should be 2
(unless your device, by itself, has a bursty behaviour).</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="c1"># Loss threshold for the timestamp estimator</span>
<span class="n">property</span> <span class="s2">"sample_loss_threshold"</span><span class="p">,</span> <span class="s2">"int"</span><span class="p">,</span> <span class="mi">2</span>
</code></pre></div>
<p>This property is passed to the constructor in the <code>configureHook</code>:</p>

<div class="highlight"><pre class="highlight cpp"><code><span class="n">mTimestamper</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">::</span><span class="n">TimestampEstimator</span><span class="p">(</span>
    <span class="n">base</span><span class="o">::</span><span class="n">Time</span><span class="o">::</span><span class="n">fromSeconds</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">base</span><span class="o">::</span><span class="n">Time</span><span class="o">::</span><span class="n">fromMilliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">_sample_loss_threshold</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</code></pre></div>
<p>The last bit of the puzzle is the integration of hardware-provided timestamps.</p>

<p>As we already explained, a lot of sensors nowadays provide hardware pulses that
announce a precise event in their data acquisition process. If such a source is
available to you, you can feed it to your component by creating a e.g.
<code>hardware_timestamps</code> port of type <code>/base/Time</code> and feed this to the estimator:</p>

<div class="highlight"><pre class="highlight ruby"><code><span class="n">input_port</span> <span class="s2">"hardware_timestamps"</span><span class="p">,</span> <span class="s2">"/base/Time"</span>
</code></pre></div>
<div class="highlight"><pre class="highlight cpp"><code><span class="n">base</span><span class="o">::</span><span class="n">Time</span> <span class="n">hw_time</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">_hardware_timestamps</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">hw_time</span><span class="p">)</span> <span class="o">==</span> <span class="n">RTT</span><span class="o">::</span><span class="n">NewData</span><span class="p">)</span>
    <span class="n">mTimestamper</span><span class="o">-&gt;</span><span class="n">updateReference</span><span class="p">(</span><span class="n">hw_time</span><span class="p">);</span>
</code></pre></div>
<p class="next-page">That's all on the topic of timestamping. Let's move on to
<a href="deployment.html">deployment</a>, to find out how the components classes we're
writing are actually executed</p>

            </div>
        </div>
    </div>

    <script>
    $('.docs-sidebar').affix({
        offset: {
            top: $('.docs-sidebar').offset().top
        }
    });
    </script>


        <footer class="container-fluid text-center">
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Building Robots with Rock and Syskit</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/doudou" property="cc:attributionName" rel="cc:attributionURL">Sylvain Joyeux</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. Copyright Sylvain Joyeux and Contributors
        </footer>
    </body>
</html>
